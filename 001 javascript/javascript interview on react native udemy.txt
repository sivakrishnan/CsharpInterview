
################## dynamic type######################

var name = 'Max';
var age = 29;
var hasHobbies = true;

function summarizeUser(userName, userAge, userHasHobby) {
  return (
    'Name is ' +
    userName +
    ', age is ' +
    userAge +
    ' and the user has hobbies: ' +
    userHasHobby
  );
}

console.log(summarizeUser(name, age, hasHobbies));

################## const vs let ######################

const name = 'Max';
let age = 29;
const hasHobbies = true;

age = 30;

function summarizeUser(userName, userAge, userHasHobby) {
  return (
    'Name is ' +
    userName +
    ', age is ' +
    userAge +
    ' and the user has hobbies: ' +
    userHasHobby
  );
}

console.log(summarizeUser(name, age, hasHobbies));

################## Arrow Function ######################

const name = 'Max';
let age = 29;
const hasHobbies = true;

age = 30;

const summarizeUser = (userName, userAge, userHasHobby) => {
  return (
    'Name is ' +
    userName +
    ', age is ' +
    userAge +
    ' and the user has hobbies: ' +
    userHasHobby
  );
};

const add = (a, b) => a + b;   // no need return statement for single statement
const addOne = a => a + 1; // no need open close paranthesis for single parameter
const addRandom = () => 1 + 2;

console.log(add(1, 2));
console.log(addOne(1));
console.log(addRandom());

console.log(summarizeUser(name, age, hasHobbies));

################## Object - Method and property ######################

const person = {
  name: 'Max',
  age: 29,
  greet() {
    console.log('Hi, I am ' + this.name);
  }
};

person.greet();

//output : Hi, I am Max

const person = {
  name: 'Max',
  age: 29,
  greet: function() {
    console.log('Hi, I am ' + this.name);
  }
};

person.greet();

//output : Hi, I am Max

const person = {
  name: 'Max',
  age: 29,
  greet: ()=> {
    console.log('Hi, I am ' + this.name);
  }
};

person.greet();

//output : Hi, I am undefined

Reason
Arrow functions do NOT have their own this.
They inherit this from the surrounding (lexical) scope.


################## Array & Array Method ######################

const person = {
  name: 'Max',
  age: 29,
  greet() {
    console.log('Hi, I am ' + this.name);
  }
};

const hobbies = ['Sports', 'Cooking', 1, true];
for (let hobby of hobbies) {
     console.log(hobby);
}

output: 
Sports
Cooking
1
true

console.log(hobbies.map(hobby => 'Hobby: ' + hobby));
console.log(hobbies);

################## spread operator & rset Parameters ######################

const hobbies = ['Sports', 'Cooking'];
const copiedArray1 = hobbies; //shallow copy
hobbies.push('test');
console.log(hobbies);
console.log(copiedArray1);

const hobbies = ['Sports', 'Cooking'];
const copiedArray = [...hobbies]; // actually copy
console.log(copiedArray);
hobbies.push('test');
console.log(hobbies);
console.log(copiedArray);

const copiedArray2 = hobbies.slice(); // actually copy
console.log(copiedArray2);

const copiedArray3 = Array.from(hobbies); // actually copy
console.log(copiedArray3);

const toArray = (...args) => {  // rest parameter merging all the parameter and convert it into array
  return args;
};

console.log(toArray(1, 2, 3, 4));
console.log(toArray(1, 2, 3));

################## Destructuring ######################

const person = {
  name: 'Max',
  age: 29,
  greet() {
    console.log('Hi, I am ' + this.name);
  }
};

const printName = ({ name }) => {  // destructuring person object and taking name property alone
  console.log(name);
};

printName(person);

const { name, age } = person; // destructuring object
console.log(name, age);

const hobbies = ['Sports', 'Cooking'];
const [hobby1, hobby2] = hobbies;   //destructuring array
console.log(hobby1, hobby2);