
1) callbacks
2) promises
3) async/await
4) Strict mode
5) Higher order function
6) call, apply, bind
7) scope
8) closures
9) Hoisting
10) IIFE (Immediately Invoked Function Expression)
11) Currying
12) Debouncing
13) Throttling
14) polyfills
15) Object creation in javascript
16) setTimeout vs SetInterval
17) Wipro interviewer asked
18) JavaScript pre defined functions
19) MSC Technology Interview

################# 2) promises

A Promise has 3 states

	Pending – request in progress. handled by fetch()
	Fulfilled – request successful. handled by then()
	Rejected – request failed. handled by catch()

syntax:	
	fetch(url).then(successHandler).catch(errorHandler);
	
1) AJAX GET request- with async / await

async function getUsers() {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");

    if (!response.ok) {
      throw new Error("HTTP Error");
    }

    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

getUsers();

2) AJAX POST request - (AJAX + Promise)


fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    title: "Hello",
    body: "AJAX with Promises",
    userId: 1
  })
})
.then(res => res.json())
.then(data => console.log(data))
.catch(err => console.error(err));



################# 5) Higher order function

Higher-order functions can both accept and return functions, enabling powerful patterns like function composition.

const funcAddbyFive = function addbyFive(x){
    return x+5
}

const funcMultiplybyTwo = function multiplybyTwo(x){
    return x*2
}

function functionCompose(addFunc, multiplyFunc){
    return (x)=>{
        return addFunc(multiplyFunc(x))
    }
}

const final= functionCompose(funcAddbyFive, funcMultiplybyTwo)

console.log(final(10))

################# 6) call(), apply(), bind()

let Employee={
    firstName:'siva',
    lastName:'krish',
    getEmployeeName:function(greetings, companyName, methodtype){
        return methodtype+'-'+ greetings+' '+companyName+' '+ this.firstName+' '+this.lastName
    }
}

let AnotherEmployee={
    firstName:'siva another',
    lastName:'krish another',
}
console.log(Employee.getEmployeeName('welcome to', 'colan', 'simple')) // output: simple-welcome to colan siva krish

console.log(Employee.getEmployeeName.call(AnotherEmployee, 'welcome to', 'colan', 'call'))// output: call-welcome to colan siva another krish another

let param=['welcome to', 'colan', 'apply']
console.log(Employee.getEmployeeName.apply(AnotherEmployee, param)) //output: apply-welcome to colan siva another krish another

const bindFunction=Employee.getEmployeeName.bind(AnotherEmployee, 'welcome to', 'colan')
console.log(bindFunction('bind')) //output: bind-welcome to colan siva another krish another


################# 7) scope

1. Global Scope
2. Function Scope (Local Scope)
3. Block Scope

################# 8) closures

Closure: The myCounter function creates a closure, allowing the inner function to access and modify the counter variable even after myCounter has finished executing.

function myCounter() {
  let counter = 0;
  return function() {
    counter++;
    console.log(counter);
  };
}

const add = myCounter();
setInterval(add, 1000);


################# 10) IIFE (Immediately Invoked Function Expression)

const add=(function() {
  let counter = 0;
  return function() {
    counter++;
    console.log(counter);
  };
})();

setInterval(add, 1000);


################# 11) Currying- meaning combination of Higher order function ( a function return a function or accept a function as argument/parameter)
, closure ( inner functon as access the parent function variable even the praent function get executed), Immediately Invoked Function)


function add(a){
    return function(b){
        return function(c){
            return a+b+c;
        }
    }
}
console.log(add(1)(2)(3))

################# 12)  Debouncing- Debouncing is a technique used to limit how often a function executes.


function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => { // return a timer id
      fn.apply(this, args);
    }, delay);
  };
}

// Usage
window.addEventListener("resize", debounce(() => {
  console.log("Resized at", new Date().toISOString());
}, 500));

################# 13) Throttling- Ensures a function executes at most once every X milliseconds, no matter how often an event fires. It’s like rate-limiting.

function throttle(fn, delay) {
  let last = 0;
  return function (...args) {
    const now = Date.now();
    if (now - last >= delay) {
      fn.apply(this, args);
      last = now;
    }
  };
}


window.addEventListener("scroll", throttle(() => {
  console.log("Scroll event at", new Date().toISOString());
}, 1000));

################# 14) polyfills-  A polyfill is a piece of code (usually JavaScript) that implements a feature that is expected in newer JavaScript engines or browsers
, but is missing in older ones.


Suppose you want to use Array.prototype.includes, which is supported in modern browsers but not in "Internet Explorer".

Without polyfill:

[1, 2, 3].includes(2); // ❌ Error in older browsers


With polyfill:

if (!Array.prototype.includes) {  // checking weather the "includes" function available or not if not do/add the logic 
  Array.prototype.includes = function(searchElement, fromIndex) {
    return this.indexOf(searchElement, fromIndex) !== -1;
  };
}

console.log([1, 2, 3].includes(2)); // ✅ Works everywhere

################# 15) Object creation in javascript

	1) Object literal 
	
		const person={
			name: 'siva',
			age:45,
			getDetails:function(){
				console.log(`${this.name} age is ${this.age}`)
			}
		}
		person.getDetails()

	2) new Object()
	
		const obj=new Object();
		obj.name='siva'
		obj.age=35;

		obj.getDetails=function(){
			console.log(`age=${this.age} and name is ${this.name}`)
		}
		obj.getDetails();
		
	3) Constructor function
	
		function person(name, age){
			this.myName=name;
			this.myAge=age;
		}
		person.prototype.getDetails=function(){
			console.log(`${this.myName} age is ${this.myAge}`)
		}

		const obj=new person('siva', 87)
		obj.getDetails()
		
		
################# 16) setTimeout vs SetInterval	

function SayHelloFromSetTimeOut (){
console.log('hai-setTimeout');
}

function SayHelloFromSetInterval (){
console.log('hai-setInterval');
}
setTimeout( SayHelloFromSetTimeOut, 3000);
setInterval(SayHelloFromSetInterval, 3000);

################# 17) Wipro interviewer asked	

console.log("start of program");
 
setTimeout(() => {
    console.log("settimeout called");
}, 4000);
 
while(true)
{
    console.log("while loop called.");
}
 
console.log("end of program");

################# 18) JavaScript pre defined functions	

1. push() – Add item to end of array
let arr = [1, 2];
arr.push(3);  //Output: [1, 2, 3]

2. pop() – Remove last item
let arr = [1, 2, 3];
arr.pop();  //Output: [1, 2]

3. shift() – Remove first item
let arr = [1, 2, 3];
arr.shift();  // [2, 3]

4. unshift() – Add item at the beginning
let arr = [2, 3];
arr.unshift(1);  // [1, 2, 3]

5. map() – Loop through array & return a new array
let arr = [1, 2, 3];
let result = arr.map(x => x * 2); // [2, 4, 6]

6. filter() – Filter array elements
let arr = [1, 2, 3, 4];
let result = arr.filter(x => x % 2 === 0); // [2, 4]

7. find() – Get first matching item
let arr = [10, 20, 30];
let result = arr.find(x => x > 10); // 20 only comes not 20, 30. only first matching

8. findIndex() – Get index of first match
let arr = ["a", "b", "c"];
let index = arr.findIndex(x => x === "b"); // 1

9. includes() – Check if element exists
let arr = ["admin", "user"];
arr.includes("admin");   // true

10. indexOf() – Find index of element
let arr = ["a", "b", "c", "b"];
arr.indexOf("b");  // 1

11. reduce() – Combine all values into one
let arr = [1, 2, 3];
let sum = arr.reduce((a, b) => a + b, 0); // 6

12. slice() – Copy part of array (non-destructive)
let arr = [1, 2, 3, 4, 5, 6, 7, 8];
let part = arr.slice(2, 4); // [3, 4]

13. splice() – Add/remove elements (destructive)
let arr = [1, 2, 3, 4, 5, 6, 7, 8];
arr.splice(1, 3); // [ 1, 5, 6, 7, 8 ]

14. concat() – Merge arrays
let arr1 = [1, 2];
let arr2 = [3, 4];
let result = arr1.concat(arr2); // [1, 2, 3, 4]

15. sort() – Sort values
let arr = [3, 1, 2];
arr.sort();   // [1, 2, 3]

16. reverse()
let arr = [1, 2, 3];
arr.reverse(); // [3, 2, 1]

17. join() – Convert array → string
["a", "b", "c"].join("-"); // "a-b-c"

18. every() – All elements satisfy condition?
[2, 4, 6].every(x => x % 2 === 0)  // true

19. some() – At least one element satisfies condition?
[1, 3, 6].some(x => x % 2 === 0) // true

20. flat() – Flatten nested arrays

[1, [2, [3]]].flat(2); // [1, 2, 3]

################# 19) MSC Technology Interview	

const obj = { 

value: 10, 
getValue() 						// short hand syntax for getValue: function(){....
	{ 
		return this.value; 
	} 
}; 

const fn = obj.getValue; // fn hold the function (getvalue) reference
console.log(obj.getValue()); // output 10
console.log(fn()); // undefined
console.log(obj.getValue.bind(obj)()); // output 10
const fnAnother=obj.getValue.bind(obj);
console.log(fnAnother()); // output 10
