Beginner ASP.NET Core Web API Interview Questions

###1) What is ASP.NET Core?

##################################################################################################################

###2) What is a Web API?

##################################################################################################################

###3) What is the difference between ASP.NET MVC and ASP.NET Core Web API?

##################################################################################################################

###4) What is REST?

	REST stands for Representational State Transfer.
	It is an architectural style (not a protocol) for designing distributed systems ‚Äî especially web services ‚Äî based on these principles:

	Stateless communication
	Resources identified by URIs
	Standard HTTP methods (GET, POST, PUT, DELETE, etc.)
	Use of standard HTTP status codes
	Transfer representations (usually JSON or XML) of resources
	Client-server separation
	
##################################################################################################################

###5) What are HTTP verbs (GET, POST, PUT, DELETE)?

##################################################################################################################

###6) What is routing in ASP.NET Core?

Routing in ASP.NET Core is the process of matching incoming HTTP requests to the appropriate controller actions or endpoints. 
ASP.NET Core supports both conventional routing and attribute routing. Routing extracts parameters from URLs, applies constraints, 
and decides which code should execute for each request.

üß© How Routing Works Internally

ASP.NET Core builds a route table
Incoming request ‚Üí framework scans route table
Finds the best-matching route pattern
Extracts route parameters
Invokes the matched endpoint
Middleware pipeline executes

Two Types of Routing in ASP.NET Core

1Ô∏è) Conventional Routing (Mostly for MVC apps)

Routes follow a pattern like:

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");


üëâ Example URL:
/Products/Details/5
Maps to ‚Üí ProductsController.Details(5)

2Ô∏è) Attribute Routing (Route defined on controllers/actions)

You specify route directly on controller actions:

[Route("api/products")]
public class ProductsController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetProduct(int id) { ... }
}


üëâ Example URL:
GET /api/products/10

##################################################################################################################

###7) How do you return JSON from a Web API?

	In ASP.NET Core Web API, JSON is returned automatically. 
	If you return a POCO object or ActionResult<T>, the framework serializes it to JSON using System.Text.Json. 
	You can also explicitly return JSON using Ok(object) or JsonResult. The response is by default application/json unless content negotiation decides otherwise."
	
	IActionResult 		  ----> return Ok(Product) 			---->return the json
	ActionResult<Product> ----> return Product 				---->return the json (behind the code, it will automatically wrapped with Ok(product)
	IActionResult 		  -----> return JsonResult(Product) ---->explicitly return the json

##################################################################################################################

###8) What is a controller in ASP.NET Core Web API?

üß© ControllerBase vs Controller
		Class				Purpose
1) ControllerBase		For Web API only (no views)
2) Controller			For MVC apps (supports views + API)

##################################################################################################################

###9) Explain the role of Startup.cs.

	The Startup.cs file configures the services and the request pipeline in ASP.NET Core. 
	The ConfigureServices method is used to "register services with the dependency injection container", such as EF Core, Identity, logging, or custom repositories. 
	The Configure method defines how the app handles "HTTP requests by setting up middleware" like routing, authentication, authorization, exception handling, etc. 
	In .NET 6+, the Startup class is optional because these configurations can be done directly in Program.cs, but the underlying concepts remain the same.

##################################################################################################################

###10) What is middleware?

	Middleware in ASP.NET Core is a software component that sits in the HTTP request pipeline. Each middleware can inspect, modify, or short-circuit a request and/or response. 
	They execute in order, so the sequence matters a lot. ASP.NET Core provides built-in middleware like routing, authentication, authorization, and exception handling, 
	and we can also create custom middleware for cross-cutting concerns like logging, caching, or rate limiting.
	
##################################################################################################################

###11) How do you test an ASP.NET Core Web API using tools like Postman?

##################################################################################################################

###12) How do you enable CORS in an ASP.NET Core Web API?

	CORS in ASP.NET Core is enabled using the AddCors service and the UseCors middleware. 
	We define a CORS policy in Program.cs or Startup.cs, specifying allowed origins, headers, and methods. 
	Then we apply that policy globally with app.UseCors("PolicyName") or per controller/action using the [EnableCors] attribute. 
	By default, ASP.NET Core blocks cross-origin requests, so enabling CORS is necessary when the frontend and backend are hosted on different domains.
	
	1. Register CORS in Program.cs
	
	// Add CORS services
	
	builder.Services.AddCors(options =>
	{
		options.AddPolicy("AllowSpecificOrigin",
			policy =>
			{
				policy.WithOrigins("https://app.example.com") // allowed origin
					  .AllowAnyHeader()
					  .AllowAnyMethod();
			});
	});
	
	
	2. Enable CORS in the middleware pipeline
	
	var app = builder.Build();

	// Use CORS globally
	app.UseCors("AllowSpecificOrigin");

	app.UseAuthorization();
	app.MapControllers();
	app.Run();
	
	3. Enable CORS per controller or action (optional)

	Instead of global, you can apply per-controller:

	[ApiController]
	[Route("api/[controller]")]
	[EnableCors("AllowSpecificOrigin")]  // apply policy here
	public class ProductsController : ControllerBase
	{
		[HttpGet]
		public IActionResult GetProducts()
		{
			return Ok(new[] { "Laptop", "Phone", "Tablet" });
		}
	}

##################################################################################################################

###13) What is dependency injection in ASP.NET Core?

Dependency Injection (DI) in ASP.NET Core is a built-in design pattern and framework feature that allows you 
to achieve loose coupling, better testability, and better maintainability by letting the system automatically provide (inject) 
the required objects (dependencies) instead of creating them manually.

üß† Types of DI in ASP.NET Core

	1) Constructor Injection (most common)
	2) Method Injection
	3) Property Injection

üîÑ Lifetime Scopes in ASP.NET Core DI

	1) Singleton ‚Üí Created once for entire app
	2) Scoped ‚Üí One instance per HTTP request
	3) Transient ‚Üí New instance every time requested

##################################################################################################################

###14) Explain the appsettings.json file.

##################################################################################################################

###15) How do you handle exceptions in an ASP.NET Core Web API?

1. Use Global Exception Handling Middleware (Recommended)
2. Using Built-in Developer Exception Page (Development only)
3. Using UseExceptionHandler Middleware
4. Use try-catch Blocks in Actions (Not recommended globally)
5. Use Exception Filters (Older but still valid)

üîπ 1. Use Global Exception Handling Middleware (Recommended)

Step 1: Create custom middleware

	public class ExceptionMiddleware
	{
		private readonly RequestDelegate _next;
		private readonly ILogger<ExceptionMiddleware> _logger;

		public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger)
		{
			_next = next;
			_logger = logger;
		}

		public async Task InvokeAsync(HttpContext httpContext)
		{
			try
			{
				await _next(httpContext);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Unhandled exception occurred");

				httpContext.Response.StatusCode = 500;
				httpContext.Response.ContentType = "application/json";

				var response = new
				{
					StatusCode = 500,
					Message = "An unexpected error occurred!",
					Detail = ex.Message
				};

				await httpContext.Response.WriteAsJsonAsync(response);
			}
		}
	}

Step 2: Register middleware in Program.cs
	app.UseMiddleware<ExceptionMiddleware>();
üëâ This makes it global ‚Äî all exceptions in the API pass through it.


üîπ 3. Using UseExceptionHandler Middleware

Useful for custom error pages or JSON formatting.

app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        context.Response.StatusCode = 500;
        context.Response.ContentType = "application/json";

        var exception = context.Features.Get<IExceptionHandlerFeature>()?.Error;

        var result = new
        {
            StatusCode = 500,
            Message = "Something went wrong!",
            Error = exception?.Message
        };

        await context.Response.WriteAsJsonAsync(result);
    });
});

üîπ 5. Use Exception Filters (Older but still valid)

public class ApiExceptionFilter : ExceptionFilterAttribute
{
    public override void OnException(ExceptionContext context)
    {
        context.Result = new JsonResult(new
        {
            Message = context.Exception.Message
        })
        { StatusCode = 500 };
    }
}

Register:


builder.Services.AddControllers(options =>
{
    options.Filters.Add<ApiExceptionFilter>();
});

##################################################################################################################


