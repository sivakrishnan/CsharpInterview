üü® Intermediate-Level EF Core Questions

10. What is Change Tracking? ---> EF Core tracks entity states (Added, Modified, Deleted, Unchanged).

11. What are Entity States? ---> Added, Modified, Deleted, Detached, Unchanged

12. What is a Shadow Property? ---> A property not defined in the entity class but defined in EF model.

	public class Product
	{
		public int Id { get; set; }
		public string Name { get; set; }
	}
	
‚úÖ 1Ô∏è) Define Shadow Property using Fluent API

DbContext
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Product>()
        .Property<DateTime>("CreatedDate")          // Shadow Property
        .HasDefaultValueSql("GETDATE()");
}


‚úî Now EF Core will create a column CreatedDate in database
‚úî But it does NOT exist in Product class

‚úÖ 2Ô∏è) Using the Shadow Property

Set its value before saving
var product = new Product
{
    Name = "Laptop"
};

context.Add(product);

// Set shadow property value
context.Entry(product).Property("CreatedDate").CurrentValue = DateTime.Now;

context.SaveChanges();

‚úÖ 3Ô∏è) Reading Shadow Property

var p = context.Products.First();
var createdDate = context.Entry(p).Property("CreatedDate").CurrentValue;

Console.WriteLine(createdDate);

13. What is Fluent API? ---> Configuration of entities using ModelBuilder.

14. Difference between HasKey, HasAlternateKey, and HasIndex?

HasKey ---> Primary key
HasAlternateKey ---> Additional unique constraint
HasIndex ---> Non-unique index

15. What is Global Query Filter? ---> To filter soft-deleted or tenant-specific data.

16. How does EF Core handle concurrency? Using, RowVersion and ConcurrencyToken

17. What is AsNoTracking()? ---> Disables change tracking ‚Üí improves read performance.

18. Difference: IQueryable vs IEnumerable in EF?

IQueryable ‚Üí executed in SQL, deferred.
IEnumerable ‚Üí executed in .NET (in-memory).

19. How to log SQL queries in EF Core?

Using: optionsBuilder.LogTo(Console.WriteLine);



20. Controls how EF loads related entities.



##################################################################################################################
How does EF Core Handle cascade delete behavior?

Behavior						Meaning
Cascade							Child rows are deleted automatically
ClientCascade					EF deletes child rows in memory; DB won‚Äôt handle it
SetNull							Foreign key is set to NULL
ClientSetNull					EF sets FK to null in memory; DB does nothing
Restrict / NoAction				Prevents delete if children exist (throws exception)


modelBuilder.Entity<Order>()
    .HasOne(o => o.Customer)  //parent entity
    .WithMany(c => c.Orders)  // child entity
    .OnDelete(DeleteBehavior.Cascade);
	
	.OnDelete(DeleteBehavior.NoAction);
	
	.OnDelete(DeleteBehavior.SetNull);
	
ClientCascade / ClientSetNull (Handled by EF, Not Database)-Used when the database cannot enforce cascade or null set.

##################################################################################################################
How does EF Core handle concurrency conflicts?

##################################################################################################################
What is the purpose of AsSplitQuery?
What is Split Query vs Single Query?

EF Core, by default, creates "Single SQL Query" with multiple JOINs This can cause: Cartesian explosion.

1) Example Linq Query for Single Query:

var orders = await db.Orders
	.Include(o => o.Customer)
    .Include(o => o.Items)    
    .ToListAsync();
	
One Order --> For One Customer --> 5 Items in this order have it then the query will be like

this will create "Single Query" - DB Round Trip will be "ONE" but duplication is Huge

select o.OrderId, o.OrderName, c.CustomerId, c.CustomerName, i.ItemId from Orders o
inner join Customer c on c.CustomerId = O.CustomerId
inner join Items i on i.OrderId = o.OrderId

in this query "o.OrderId, o.OrderName, c.CustomerId, c.CustomerName" these colums are duplicated. this is called "Cartesian explosion"


2) Convert this Linq to Split Query

var orders = await db.Orders
	.Include(o => o.Customer)
    .Include(o => o.Items)    
	.AsSplitQuery() // this will convert the single sql query to split query
    .ToListAsync();
	

"AsSplitQuery" will create "Split Query" - DB Round Trip will be "Three (for this example)" but avoid the duplication

Query 1: select o.OrderId, o.OrderName from  Orders o
Query 2: select c.CustomerId, c.CustomerName from Customer c where c.CustomerId = '___@O.CustomerId___'
Query 3: select i.ItemId from Items i where i.OrderId = '___@o.OrderId___'

Comparison Split Query vs Single Query

Mode							Behavior						Pros									Cons
------------------------------------------------------------------------------------------------------------------------------------------------------
Single Query (default)			Big JOIN query					Fewer DB round trips					Duplicate rows, slow for large includes
Split Query						Multiple small queries			Better performance for collections      More DB round trips


##################################################################################################################
How does EF Core translate LINQ expressions into SQL?
How do complied query improve performance in EF Core?

	Step						Description
1. Build Expression Tree		LINQ captured as an expression; not executed yet

2. Query Compilation			EF Core validates & optimizes- identify the supported methods like Where(), Select(), OrderBy(), Join(), GroupBy() etc

3. SQL Translation				Expression tree ‚Üí SQL

4. Parameterization				Safe SQL with parameters - To prevent SQL injection and improve performance:
								.Where(a => a.Status == "Active") 
								SELECT * FROM Assets WHERE Status = @__Status_0
								
5. Query Execution				Database runs the SQL - Execution happens only when you call: .ToList(), .First(), .FirstOrDefault(), .Count(), await ToListAsync()

6. Materialization				Rows returned ‚Üí C# objects - The database returns rows ‚Üí EF Core maps them to your C# model objects.
								SELECT asset_id, name FROM Assets
								new Asset { AssetId = 30, Name = "Laptop" }


Example:

var results = context.Employees
    .Where(e => e.DepartmentId == 2)
    .OrderBy(e => e.Name)
    .Select(e => new { e.Id, e.Name })
    .ToList();
	
SELECT e.Id, e.Name
FROM Employees AS e
WHERE e.DepartmentId = @__depId_0
ORDER BY e.Name;

Complieed Query : EF Core pre-translates (first three steps) your query once, stores the SQL plan in memory, and reuses it every time you execute the query.

üîÅ Normal Query:  LINQ ‚Üí EF Core ‚Üí SQL (translated every time)
‚ö° Compiled Query:  LINQ ‚Üí SQL (translated once, reused thousands of times)

üìå Simple Example
static readonly Func<AppDbContext, int, Task<User>> GetUserById =
    EF.CompileAsyncQuery((AppDbContext db, int id) =>
        db.Users.AsNoTracking().FirstOrDefault(u => u.Id == id)
    );

// usage
var user = await GetUserById(_context, 10);



##################################################################################################################
How do you execute raw sql query in EF Core?

1. Raw SQL Query Returning Entities (FromSqlRaw, FromSqlInterpolated)
2. Raw SQL Query Returning Non-Entity Types (SqlQueryRaw)
3. Running SQL Without Returning Results (ExecuteSqlRawAsync, ExecuteSqlInterpolatedAsync)
4. Using ADO.NET Inside EF Core


1. Raw SQL Query Returning Entities (FromSqlRaw, FromSqlInterpolated)

Best when your SQL returns data matching your entity model.

----> With parameters:
var id = 10;
var result = await _context.Assets
    .FromSqlRaw("SELECT * FROM asset WHERE id = {0}", id)
    .ToListAsync();


----> OR (safer)

var result = await _context.Assets
    .FromSqlInterpolated($"SELECT * FROM asset WHERE id = {id}")
    .ToListAsync();
	
----> Stored procedure returning rows:

var employees = await _context.Employees
    .FromSqlRaw("CALL get_active_employees()")
    .ToListAsync();

----> Stored procedure with parameters:
var id = 5;
var result = await _context.Assets
    .FromSqlInterpolated($"CALL get_asset_details({id})")
    .ToListAsync();
	

2. Raw SQL Query Returning Non-Entity Types

When SQL does not map to a DbSet (e.g., stored procedure output, custom columns).

EF Core 7+:

var result = await _context.Database
    .SqlQueryRaw<MyDto>("SELECT id, name FROM asset")
    .ToListAsync();


DTO:

public class MyDto {
    public int Id { get; set; }
    public string Name { get; set; }
}


3. Running SQL Without Returning Results

----> Used for INSERT, UPDATE, DELETE, TRUNCATE, etc.

await _context.Database.ExecuteSqlRawAsync(
    "UPDATE asset SET status = 'Inactive' WHERE id = {0}", id);


----> Example with safe parameter:

await _context.Database.ExecuteSqlInterpolatedAsync(
    $"DELETE FROM asset WHERE id = {id}");
	
4. Using ADO.NET Inside EF Core

	using var cmd = _context.Database.GetDbConnection().CreateCommand();
	cmd.CommandText = "SELECT COUNT(*) FROM asset";
	_context.Database.OpenConnection();

	var count = (int)await cmd.ExecuteScalarAsync();

##################################################################################################################
How do you optimize EF Core queries for high traffice read workloads?

1. Use AsNoTracking() for Read-Only Queries
2. Use Compiled Queries (EF Core CompiledQuery)
3. Add Proper Indexes
4. Use Projections (Select) Instead of Returning Full Entities
5. Use Database-Level Caching or In-Memory Cache for Repeated Reads
6. Avoid N+1 Queries
7. Limit Returned Rows
8. Use NoTrackingWithIdentityResolution When Needed
9. Use Raw SQL for Very Complex Queries
10. Use Read Replicas for Scaling

1. Use AsNoTracking() for Read-Only Queries

	var data = await _context.Users
    .AsNoTracking()
    .ToListAsync();
	
	---> Avoids change-tracking overhead
	---> Essential for high-traffic APIs
	---> Query becomes faster and uses less memory
	
2. Use Compiled Queries (EF Core CompiledQuery)

	Great for queries executed thousands of times.

	static readonly Func<MyDb, int, Task<User>> _getUser =
		EF.CompileAsyncQuery((MyDb db, int id) =>
			db.Users.AsNoTracking().FirstOrDefault(u => u.Id == id)
		);

	var user = await _getUser(_context, id);

	---> Removes query translation overhead
	---> Big performance boost in high-load scenarios
	
3. Add Proper Indexes 

HasKey ---> Primary key
HasAlternateKey ---> Additional unique constraint
HasIndex ---> Non-unique index

Your DB must match your query patterns.

Examples:

CREATE INDEX IX_Users_Email ON Users(Email);
CREATE INDEX IX_Orders_UserId ON Orders(UserId);


‚úî Indexes are the #1 factor for speed
‚úî Without indexes, EF Core becomes slow no matter what
	
4. Use Projections (Select) Instead of Returning Full Entities

Instead of:

var users = await _context.Users.ToListAsync();


Use:

var users = await _context.Users
    .Select(x => new UserDTO { Id = x.Id, Name = x.Name })
    .AsNoTracking()
    .ToListAsync();


	---> Reduces network traffic
	---> Reduces memory usage
	---> Faster materialization
	

5. Use Database-Level Caching or In-Memory Cache for Repeated Reads

For frequently accessed reference data:

In-Memory Cache

	var data = await _memoryCache.GetOrCreateAsync("locations", entry =>
	{
		entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1);
		return _context.Locations.AsNoTracking().ToListAsync();
	});

Redis Cache

Use Redis for large-scale read-heavy applications.

‚úî Reduces DB hits
‚úî Much faster response times

6. Avoid N+1 Queries -Use .Include() or ThenInclude() when appropriate:

var orders = await _context.Orders
    .Include(o => o.OrderItems)
    .AsNoTracking()
    .ToListAsync();


Or even better, project only what is required:

var orders = await _context.Orders
    .Select(o => new {
        o.Id,
        Items = o.OrderItems.Select(i => new { i.Name, i.Price })
    })
    .AsNoTracking()
    .ToListAsync();
	
7. Limit Returned Rows

Use filtering, pagination:

var logs = await _context.Logs
    .Where(l => l.CreatedOn >= start && l.CreatedOn <= end)
    .OrderByDescending(l => l.Id)
    .Skip(page * size)
    .Take(size)
    .AsNoTracking()
    .ToListAsync();


‚úî Prevents accidental full table scans
‚úî Necessary for heavy traffic

8. Use NoTrackingWithIdentityResolution When Needed

When you want non-tracked entities but still avoid duplicates:

.AsNoTrackingWithIdentityResolution()


‚úî Useful for graph queries
‚úî Still faster than full tracking

9. Use Raw SQL for Very Complex Queries
var data = _context.Users
    .FromSqlRaw("SELECT id, name FROM users WHERE is_active = true")
    .AsNoTracking()
    .ToListAsync();


‚úî Gives full SQL control
‚úî Can be much faster if EF struggles to translate a complex LINQ

10. Use Read Replicas for Scaling

Use PostgreSQL / SQL Server read replicas:

	Write ‚Üí Primary DB
	Reads ‚Üí Read replicas

	In .NET read replicas connectin string

		options.UseNpgsql(ReadReplicaConnectionString);


‚úî Handles massive read load
‚úî Ensures your primary database is not overloaded


##################################################################################################################
How do you implement soft delete in EF Core? interlocked
What are global query filter and when they are used?

In EF Core, soft delete means you don‚Äôt physically delete a row. Instead, 
you mark it as deleted (e.g., IsDeleted = true) and automatically exclude it from queries.

What are global query filter and when they are used?

‚úÖ Common Use Cases-Global Filter

1Ô∏è) Soft Delete

Exclude logically deleted rows

modelBuilder.Entity<Asset>()
    .HasQueryFilter(e => !e.IsDeleted);

_context.Assets.ToList(); // returns only non-deleted records

2Ô∏è) Multi-Tenancy

Restrict data per tenant

modelBuilder.Entity<Order>()
    .HasQueryFilter(o => o.TenantId == _tenantProvider.TenantId);

3Ô∏è) Active / Inactive Records

Filter active rows only

modelBuilder.Entity<User>()
    .HasQueryFilter(u => u.IsActive);

4Ô∏è) Security / Data Isolation

Hide unauthorized data automatically

modelBuilder.Entity<Document>()
    .HasQueryFilter(d => d.OwnerId == _currentUser.Id);

‚úÖ How to Define a Global Query Filter
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Asset>()
        .HasQueryFilter(x => !x.IsDeleted);
}

‚úÖ 1. Add Soft Delete Columns to Entity
public abstract class BaseEntity
{
    public bool IsDeleted { get; set; }
    public DateTime? DeletedAt { get; set; }
}


Example entity:

public class Asset : BaseEntity
{
    public int Id { get; set; }
    public string Name { get; set; }
}

‚úÖ 2. Global Query Filter (Most Important Step)

This ensures all queries automatically ignore deleted records.

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Asset>()
        .HasQueryFilter(e => !e.IsDeleted);
}


üîπ Now:

_context.Assets.ToList(); // Only non-deleted rows

‚úÖ 3. Override SaveChanges() to Convert Delete ‚Üí Soft Delete
public override int SaveChanges()
{
    SoftDelete();
    return base.SaveChanges();
}

public override async Task<int> SaveChangesAsync(
    CancellationToken cancellationToken = default)
{
    SoftDelete();
    return await base.SaveChangesAsync(cancellationToken);
}

private void SoftDelete()
{
    foreach (var entry in ChangeTracker.Entries<BaseEntity>())
    {
        if (entry.State == EntityState.Deleted)
        {
            entry.State = EntityState.Modified;
            entry.Entity.IsDeleted = true;
            entry.Entity.DeletedAt = DateTime.UtcNow;
        }
    }
}


‚úî Calling _context.Remove(entity) now performs a soft delete

‚úÖ 4. Querying Deleted Data (When Needed)

var allAssets = _context.Assets.IgnoreQueryFilters().ToList();

‚úÖ 5. Hard Delete (Optional)

	_context.Assets.IgnoreQueryFilters()
		.Where(x => x.IsDeleted)
		.ExecuteDelete();


##################################################################################################################
How do you apply EF Core migration in production?

Option 1: Generate SQL script (Manual Execution)

	dotnet ef migrations script -o migration.sql
	OR
	dotnet ef migrations script PreviousMigration LatestMigration -o migration.sql
	
Option 2: For Cloud Platform (Pipline Execution)

Add migration step in pipeline:

	dotnet ef database update --project YourProject.csproj
	
	

##################################################################################################################
How does connection pooling behave in EF Core?

##################################################################################################################
What is the difference between Table-per-Hierarchy, Table-per-Type and Table-per-Concrete-Type inheritance in EF Core?

##################################################################################################################
What are owned type in EF Core?

##################################################################################################################

What is the difference between Eager loading, Explicit loading and Lazy loading in EF Core?

##################################################################################################################
